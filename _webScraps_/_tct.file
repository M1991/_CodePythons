Getting the HL for all tops
Classic 15' and 1"

for t in ts
  get the 1st top,
  get 2nd top,
  get the 3rd top,
  difference in ratio of tops to total v
  
Identifying Support and Resistance with Python - Part 1 of 2

Objective
Wherever possible, I prefer to use existing code from established online repositories.  Why reinvent the wheel if you don't need to?  However, I had a very hard time finding any good Python code, or even good pseudo code (that I could use to write the Python code) to effectively identify Support and Resistance (S&R) in price action.  So I decided to write my own.  To accomplish this, I first wanted to define a good methodology for identifying S&R, by breaking down the way that a human analyst would identify S&R by looking at the charts.  Then after defining the approach, we build the code to those specifications.
How to identify support & resistance levels
Interpretations of S&R levels is very subjective.  A lot of people do it different ways.  The intention of this was not to argue the superiority of one way or another, but rather to just automate the way that I identify S&R.  When I am evaluating S&R from the charts, I am looking for two primary things:

Bounce off - There needs to be a visible departure (bounce off) from the horizontal line which is perceived to define the level of support or resistance.
Multiple touches - A single touch turning point is not sufficient to indicate establish support or resistance levels.  Multiple touches to the same approximately level should be present, such that a horizontal line could be drawn through those turning points.


Automation Plans
A couple considerations that I wanted to be mindful of before automating included the following:
Approximate likeness - When a human analyst examines support and resistance lines, there is a margin of error that is intuitively considered when evaluating likeness.  If you programmatically require that the touch point of a support or resistance level always be exactly the same value (down to the precise pip/pipette level), you are going to miss a lot of cases that could still be reasonably considered levels of support and resistance.  To account for this, I wanted to make sure to include a margin of error (i.e. if turning points are within a certain percent of the recent price movement, it could still be considered like values).  Bounce off could also be evaluated in the same way (i.e. departure from the support or resistance line by a defined percentage of total price movement).
Malleability - I also wanted to ensure that one could easily manipulate these threshold levels through function arguments.
Support and resistance function

def supres(low, high, min_touches=2, stat_likeness_percent=1.5, bounce_percent=5):
    """Support and Resistance Testing
    Identifies support and resistance levels of provided price action data.
    Args:
        low(pandas.Series): A pandas Series of lows from price action data.
        high(pandas.Series): A pandas Series of highs from price action data.
        min_touches(int): Minimum # of touches for established S&R.
        stat_likeness_percent(int/float): Acceptable margin of error for level.
        bounce_percent(int/float): Percent of price action for established bounce.
    
    ** Note **
        If you want to calculate support and resistance without regard for
        candle shadows, pass close values for both low and high.
    Returns:
        sup(float): Established level of support or None (if no level)
        res(float): Established level of resistance or None (if no level)
    """
    # Setting default values for support and resistance to None
    sup = None
    res = None
    
    # Identifying local high and local low
    maxima = high.max()
    minima = low.min()
    
    # Calculating distance between max and min (total price movement)
    move_range = maxima - minima
    
    # Calculating bounce distance and allowable margin of error for likeness
    move_allowance = move_range * (stat_likeness_percent / 100)
    bounce_distance = move_range * (bounce_percent / 100)
    
    # Test resistance by iterating through data to check for touches delimited by bounces
    touchdown = 0
    awaiting_bounce = False
    for x in range(0, len(high)):
        if abs(maxima - high[x]) < move_allowance and not awaiting_bounce:
            touchdown = touchdown + 1
            awaiting_bounce = True
        elif abs(maxima - high[x]) > bounce_distance:
            awaiting_bounce = False
    if touchdown >= min_touches:
        res = maxima
        
    # Test support by iterating through data to check for touches delimited by bounces
    touchdown = 0
    awaiting_bounce = False
    for x in range(0, len(low)):
        if abs(low[x] - minima) < move_allowance and not awaiting_bounce:
            touchdown = touchdown + 1
            awaiting_bounce = True
        elif abs(low[x] - minima) > bounce_distance:
            awaiting_bounce = False
    if touchdown >= min_touches:
        sup = minima
    return sup,res
    
    
Analysis in bulk and identification of S&R breaks
The original code I introduced in Part 1 was only written to detect a single instance of support and/or resistance based on recent price-action movement.  It works great if you want to recent price action and see if there is current established levels of S&R, but not ideal for doing backtesting of historical data in bulk.  Since publishing the original script, have had multiple requests to update the script so that it would take a large data-frame of historical (OHLC) price-movement data, and will break it into chunks for analysis.

I have now written an updated version of the script that will does just that.  So how is it different from the last one?

New argument - In addition to the arguments that were supplied for the previous script, this one takes one additional argument.  Specifically n for the number of frames that are evaluated at a time when inspecting the data for S&R levels.
Output format - Now instead of returning a single support or resistance value, it returns a data-frame that contains support and resistance levels for all data rows (based on the n number of data points prior to).
S&R breaks - Also within the returned data frame, are binary indicators for S&R breaks (columns for sup_break, and res_break).  If a past level of support or resistance has been broken, a 1 is returned for the corresponding data column on the given row.  A 1 value indicates a break has occurred, and a 0 indicates that a break has not occurred.
Updated code
def supres(low, high, n=28, min_touches=2, stat_likeness_percent=1.5, bounce_percent=5):
    """Support and Resistance Testing
    Identifies support and resistance levels of provided price action data.
    Args:
        n(int): Number of frames to evaluate
        low(pandas.Series): A pandas Series of lows from price action data.
        high(pandas.Series): A pandas Series of highs from price action data.
        min_touches(int): Minimum # of touches for established S&R.
        stat_likeness_percent(int/float): Acceptable margin of error for level.
        bounce_percent(int/float): Percent of price action for established bounce.
    
    ** Note **
        If you want to calculate support and resistance without regard for
        candle shadows, pass close values for both low and high.
    Returns:
        sup(float): Established level of support or None (if no level)
        res(float): Established level of resistance or None (if no level)
    """
    import pandas as pd
    import numpy as np

    # Collapse into dataframe
    df = pd.concat([high, low], keys = ['high', 'low'], axis=1)
    df['sup'] = pd.Series(np.zeros(len(low)))
    df['res'] = pd.Series(np.zeros(len(low)))
    df['sup_break'] = pd.Series(np.zeros(len(low)))
    df['sup_break'] = 0
    df['res_break'] = pd.Series(np.zeros(len(high)))
    df['res_break'] = 0
    
    for x in range((n-1)+n, len(df)):
        # Split into defined timeframes for analysis
        tempdf = df[x-n:x+1]
        
        # Setting default values for support and resistance to None
        sup = None
        res = None
        
        # Identifying local high and local low
        maxima = tempdf.high.max()
        minima = tempdf.low.min()
        
        # Calculating distance between max and min (total price movement)
        move_range = maxima - minima
        
        # Calculating bounce distance and allowable margin of error for likeness
        move_allowance = move_range * (stat_likeness_percent / 100)
        bounce_distance = move_range * (bounce_percent / 100)
        
        # Test resistance by iterating through data to check for touches delimited by bounces
        touchdown = 0
        awaiting_bounce = False
        for y in range(0, len(tempdf)):
            if abs(maxima - tempdf.high.iloc[y]) < move_allowance and not awaiting_bounce:
                touchdown = touchdown + 1
                awaiting_bounce = True
            elif abs(maxima - tempdf.high.iloc[y]) > bounce_distance:
                awaiting_bounce = False
        if touchdown >= min_touches:
            res = maxima
        # Test support by iterating through data to check for touches delimited by bounces
        touchdown = 0
        awaiting_bounce = False
        for y in range(0, len(tempdf)):
            if abs(tempdf.low.iloc[y] - minima) < move_allowance and not awaiting_bounce:
                touchdown = touchdown + 1
                awaiting_bounce = True
            elif abs(tempdf.low.iloc[y] - minima) > bounce_distance:
                awaiting_bounce = False
        if touchdown >= min_touches:
            sup = minima
        if sup:
            df['sup'].iloc[x] = sup
        if res:
            df['res'].iloc[x] = res
    res_break_indices = list(df[(np.isnan(df['res']) & ~np.isnan(df.shift(1)['res'])) & (df['high'] > df.shift(1)['res'])].index)
    for index in res_break_indices:
        df['res_break'].at[index] = 1
    sup_break_indices = list(df[(np.isnan(df['sup']) & ~np.isnan(df.shift(1)['sup'])) & (df['low'] < df.shift(1)['sup'])].index)
    for index in sup_break_indices:
        df['sup_break'].at[index] = 1
    ret_df = pd.concat([df['sup'], df['res'], df['sup_break'], df['res_break']], keys = ['sup', 'res', 'sup_break', 'res_break'], axis=1)
    return ret_df   
